"""Verilator Cc Rules."""

load("@rules_cc//cc:find_cc_toolchain.bzl", "find_cpp_toolchain")
load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
load("@rules_cc//cc/common:cc_info.bzl", "CcInfo")
load("//verilog:verilog_info.bzl", "VerilogInfo")
load(":verilator_utils.bzl", "collect_transitive_verilog_sources")

def _cc_compile_and_link_static_library(
        *,
        ctx,
        srcs,
        hdrs,
        deps,
        runfiles,
        includes = [],
        defines = [],
        copts = [],
        linkopts = []):
    """Compile and link C++ source into a static library

    Args:
        ctx: Context for rule
        srcs: The cpp sources generated by verilator.
        hdrs: The headers generated by verilator.
        deps: Library dependencies to build with.
        runfiles: Data dependencies that are read at runtime.
        includes: The includes for the verilator module to build.
        defines: Cpp defines to build with.
        copts: Additional C++ compilation flags.
        linkopts: Additional linker flags.

    Returns:
        CCInfo with the compiled library.
    """
    cc_toolchain = find_cpp_toolchain(ctx)
    feature_configuration = cc_common.configure_features(
        ctx = ctx,
        cc_toolchain = cc_toolchain,
        requested_features = ctx.features,
        unsupported_features = ctx.disabled_features,
    )

    compilation_contexts = [dep[CcInfo].compilation_context for dep in deps]
    compilation_context, compilation_outputs = cc_common.compile(
        name = ctx.label.name,
        actions = ctx.actions,
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        user_compile_flags = copts,
        srcs = srcs,
        includes = includes,
        defines = defines,
        public_hdrs = hdrs,
        compilation_contexts = compilation_contexts,
    )

    linking_contexts = [dep[CcInfo].linking_context for dep in deps]
    linking_context, linking_output = cc_common.create_linking_context_from_compilation_outputs(
        actions = ctx.actions,
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        compilation_outputs = compilation_outputs,
        linking_contexts = linking_contexts,
        name = ctx.label.name,
        user_link_flags = linkopts,
        disallow_dynamic_library = True,
    )

    output_files = []
    if linking_output.library_to_link.static_library != None:
        output_files.append(linking_output.library_to_link.static_library)
    if linking_output.library_to_link.dynamic_library != None:
        output_files.append(linking_output.library_to_link.dynamic_library)

    return [
        DefaultInfo(
            files = depset(output_files),
            runfiles = ctx.runfiles(files = runfiles),
        ),
        CcInfo(
            compilation_context = compilation_context,
            linking_context = linking_context,
        ),
    ]

def _verilator_cc_library_impl(ctx):
    # Get the verilator toolchain
    verilator_toolchain = ctx.toolchains["//verilator:toolchain_type"]

    module_info = ctx.attr.module[VerilogInfo]
    module_name, _, _ = module_info.top.basename.partition(".")
    direct_srcs, includes, inputs = collect_transitive_verilog_sources(module_info)

    output_src_dir = ctx.actions.declare_directory("{}/cc".format(ctx.label.name))
    output_hdr_dir = ctx.actions.declare_directory("{}/h".format(ctx.label.name))
    output_dir = output_src_dir.dirname

    vopts = verilator_toolchain.vopts + ctx.attr.vopts

    # Build verilator compile command
    args = ctx.actions.args()
    args.add(verilator_toolchain.verilator, format = "--verilator=%s")
    args.add_all(direct_srcs, format_each = "--src=%s")
    args.add(output_dir, format = "--output=%s")
    args.add(output_src_dir.path, format = "--output_srcs=%s")
    args.add(output_hdr_dir.path, format = "--output_hdrs=%s")

    # Add delimiter before verilator arguments
    args.add("--")

    # Add verilator flags
    args.add("--no-std")
    args.add("--cc")
    args.add("--Mdir", output_dir)
    args.add("--top-module", module_name)
    args.add("--prefix", "V" + module_name)
    args.add_all(includes, format_each = "-I%s")

    # Add verilog files (will be replaced by wrapper via source_mappings)
    args.add_all(direct_srcs)

    args.add_all(vopts)

    # Run verilator compile action
    ctx.actions.run(
        mnemonic = "VerilatorCompile",
        executable = ctx.executable._verilator_process_wrapper,
        arguments = [args],
        tools = verilator_toolchain.all_files,
        inputs = inputs,
        outputs = [output_src_dir, output_hdr_dir],
    )

    defines = []
    if "--trace" in vopts:
        defines.append("VM_TRACE")

    # Compile and link the C++ library
    return _cc_compile_and_link_static_library(
        ctx = ctx,
        srcs = [output_src_dir],
        hdrs = [output_hdr_dir],
        defines = defines,
        copts = verilator_toolchain.copts + ctx.attr.copts,
        linkopts = verilator_toolchain.linkopts + ctx.attr.linkopts,
        runfiles = ctx.files.data,
        includes = [output_hdr_dir.path, output_src_dir.path],
        deps = [verilator_toolchain.libverilator] + verilator_toolchain.deps,
    )

verilator_cc_library = rule(
    doc = """Compiles a Verilog module to a C++ library using Verilator.

    This rule collects all transitive Verilog dependencies, compiles them to
    C++ sources using Verilator, then compiles and links them into a static library.

    Example:
        verilog_library(
            name = "my_module",
            srcs = ["my_module.sv"],
        )

        verilator_cc_library(
            name = "my_module_cc",
            module = ":my_module",
        )
    """,
    implementation = _verilator_cc_library_impl,
    attrs = {
        "copts": attr.string_list(
            doc = "List of additional C++ compilation flags",
            default = [],
        ),
        "data": attr.label_list(
            doc = "Data used at runtime by the library",
            allow_files = True,
        ),
        "linkopts": attr.string_list(
            doc = "List of additional C++ linker flags",
            default = [],
        ),
        "module": attr.label(
            doc = "The top level Verilog module target to compile with Verilator.",
            providers = [VerilogInfo],
            mandatory = True,
        ),
        "vopts": attr.string_list(
            doc = "List of additional Verilator flags.",
            default = [],
        ),
        "_verilator_process_wrapper": attr.label(
            doc = "The Verilator process wrapper binary.",
            executable = True,
            cfg = "exec",
            default = Label("//verilator/private:verilator_process_wrapper"),
        ),
    },
    provides = [
        CcInfo,
        DefaultInfo,
    ],
    toolchains = [
        "@rules_cc//cc:toolchain_type",
        "//verilator:toolchain_type",
    ],
    fragments = ["cpp"],
)
